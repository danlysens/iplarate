<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>–û—Å—Ç—Ä–æ–≤ —Å–æ–∫—Ä–æ–≤–∏—â ‚Äî –°—Ç–∞–±–∏–ª—å–Ω—ã–π –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä</title>
  <style>
    * { box-sizing: border-box; user-select: none; }
    body {
      margin: 0; padding: 0;
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #6a11cb, #2575fc);
      color: #2c3e50;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .screen { display: none; width: 100%; max-width: 650px; }
    .active { display: block !important; }
    h1 {
      font-size: 2.2rem; color: white;
      text-shadow: 0 2px 5px rgba(0,0,0,0.3);
      margin-bottom: 20px;
      text-align: center;
    }
    .btn {
      padding: 12px 24px;
      font-size: 1.1rem;
      margin: 10px 5px;
      border: none;
      border-radius: 50px;
      background: white;
      color: #2c3e50;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      transition: all 0.2s;
      min-width: 220px;
    }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 14px rgba(0,0,0,0.25); }
    .btn:active { transform: translateY(0); }
    .btn.green { background: #2ecc71; color: white; }
    .btn.blue { background: #3498db; color: white; }
    .btn.red { background: #e74c3c; color: white; }
    .btn.yellow { background: #f39c12; color: white; }
    .input-group {
      margin: 20px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    input {
      padding: 12px;
      font-size: 1.1rem;
      width: 220px;
      border: none;
      border-radius: 50px;
      text-align: center;
      margin: 10px 0;
      font-weight: bold;
    }
    #lobby-info {
      background: rgba(255,255,255,0.85);
      padding: 15px;
      border-radius: 20px;
      margin: 20px 0;
      font-weight: 600;
      box-shadow: 0 4px 10px rgba(0,0,0,0.15);
      text-align: center;
    }
    #game-info {
      font-size: 1.25rem;
      font-weight: 700;
      padding: 12px 24px;
      border-radius: 40px;
      margin: 15px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.18);
      min-height: 30px;
    }
    .player-1-turn { background: rgba(255,255,255,0.92); color: #e74c3c; }
    .player-2-turn { background: rgba(255,255,255,0.92); color: #3498db; }
    #board {
      display: inline-grid;
      grid-template-columns: repeat(10, 42px);
      gap: 2px;
      margin: 20px auto;
      background: rgba(255,255,255,0.15);
      padding: 10px;
      border-radius: 12px;
      backdrop-filter: blur(6px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.2);
    }
    .cell {
      width: 42px; height: 42px;
      background: rgba(255,255,255,0.7);
      border-radius: 8px;
      display: flex; align-items: center; justify-content: center;
      font-weight: bold; font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .cell:hover { transform: scale(1.05); background: rgba(255,255,255,0.9); }
    .start { background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; }
    .treasure { background: linear-gradient(135deg, #f1c40f, #f39c12); color: #2c3e50; }
    .player { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
    .trap-revealed {
      animation: flashTrap 0.6s ease;
      color: white !important;
    }
    @keyframes flashTrap {
      0%,100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(231,76,60,0.7); }
      50% { transform: scale(1.1); box-shadow: 0 0 0 14px rgba(231,76,60,0); }
    }
    .win { animation: celebrate 0.8s ease infinite; }
    @keyframes celebrate {
      0%,100% { transform: rotate(0deg); }
      25%,75% { transform: rotate(4deg); }
      50% { transform: rotate(-4deg); }
    }
    .status { 
      margin: 15px 0; 
      padding: 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.2);
      color: white;
      font-size: 0.95rem;
      text-align: center;
    }
    .connection-status {
      padding: 8px 16px;
      border-radius: 20px;
      margin: 10px 0;
      font-weight: bold;
      display: inline-block;
    }
    .connected { background: #2ecc71; color: white; }
    .connecting { background: #f39c12; color: white; }
    .disconnected { background: #e74c3c; color: white; }
    .reconnecting { background: #9b59b6; color: white; }
    #qr-container {
      margin: 20px 0;
      display: flex;
      justify-content: center;
    }
    #qr-code {
      background: white;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    .players-list {
      margin: 15px 0;
      padding: 10px;
      background: rgba(255,255,255,0.2);
      border-radius: 10px;
    }
    .hidden { display: none; }
    .instructions {
      background: rgba(255,255,255,0.2);
      padding: 15px;
      border-radius: 10px;
      margin: 15px 0;
      font-size: 0.95rem;
      line-height: 1.4;
    }
    .retry-info {
      background: rgba(255,255,255,0.2);
      padding: 8px;
      border-radius: 8px;
      margin: 8px 0;
      font-size: 0.9rem;
    }
    .connection-log {
      height: 100px;
      overflow-y: auto;
      background: rgba(0,0,0,0.2);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-family: monospace;
      font-size: 0.85rem;
      margin: 15px 0;
      text-align: left;
    }
  </style>
</head>
<body>
  <!-- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é -->
  <div id="menu-screen" class="screen active">
    <h1>üèùÔ∏è –û—Å—Ç—Ä–æ–≤ —Å–æ–∫—Ä–æ–≤–∏—â</h1>
    <button id="btn-local" class="btn green">üéÆ –ò–≥—Ä–∞—Ç—å –Ω–∞ –æ–¥–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ</button>
    <button id="btn-create" class="btn blue">‚ûï –°–æ–∑–¥–∞—Ç—å –æ–Ω–ª–∞–π–Ω-–∏–≥—Ä—É</button>
    <div class="input-group">
      <input type="text" id="room-code" placeholder="–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã" maxlength="8" />
      <button id="btn-join" class="btn blue">üîó –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</button>
    </div>
    <div class="instructions">
      <strong>–ù–∞–¥–µ–∂–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ:</strong><br>
      ‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ–≤—Ç–æ—Ä–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏<br>
      ‚Ä¢ –†–µ–∑–µ—Ä–≤–Ω—ã–π WebSocket-–∫–∞–Ω–∞–ª<br>
      ‚Ä¢ –¢–∞–π–º–∞—É—Ç—ã –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∑–∞–≤–∏—Å–∞–Ω–∏–π<br>
      ‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    </div>
    <div class="status">
      –î–ª—è –æ–Ω–ª–∞–π–Ω-–∏–≥—Ä—ã –Ω—É–∂–µ–Ω –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.<br>
      –°–∏—Å—Ç–µ–º–∞ —Å–∞–º–∞ –≤—ã–±–µ—Ä–µ—Ç –ª—É—á—à–∏–π —Å–ø–æ—Å–æ–± –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.
    </div>
  </div>

  <!-- –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è (—Ö–æ—Å—Ç) -->
  <div id="host-screen" class="screen">
    <h1>üè† –í—ã ‚Äî –•–û–ó–Ø–ò–ù</h1>
    <div class="status">–û–∂–∏–¥–∞–Ω–∏–µ –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞...</div>
    <div id="qr-container">
      <div id="qr-code"></div>
    </div>
    <div class="connection-status connecting" id="host-status">
      –ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã: <span id="host-code">XXXXXX</span>
    </div>
    <div class="players-list">
      <div>–ò–≥—Ä–æ–∫ 1 (–í—ã): ‚úÖ –û–Ω–ª–∞–π–Ω</div>
      <div>–ò–≥—Ä–æ–∫ 2: ‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ...</div>
    </div>
    <div class="connection-log" id="host-log"></div>
    <button id="btn-cancel-host" class="btn red">–û—Ç–º–µ–Ω–∏—Ç—å</button>
  </div>

  <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Ö–æ—Å—Ç—É (–≥–æ—Å—Ç—å) -->
  <div id="guest-screen" class="screen">
    <h1>üîó –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Ö–æ—Å—Ç—É</h1>
    <div class="status">–ü—ã—Ç–∞–µ–º—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ...</div>
    <input type="text" id="guest-code" placeholder="–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã" maxlength="8" value="" readonly />
    <div class="connection-status connecting" id="guest-status">
      –°—Ç–∞—Ç—É—Å: –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...
    </div>
    <div class="retry-info">
      –ï—Å–ª–∏ –∑–∞–≤–∏—Å–ª–æ ‚Äî –Ω–∞–∂–º–∏—Ç–µ "–û—Ç–º–µ–Ω–∏—Ç—å" –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.<br>
      –°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–ø—Ä–æ–±—É–µ—Ç —Ä–∞–∑–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.
    </div>
    <div class="connection-log" id="guest-log"></div>
    <button id="btn-cancel-guest" class="btn red">–û—Ç–º–µ–Ω–∏—Ç—å</button>
    <button id="btn-force-websocket" class="btn yellow hidden">üîÑ –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ WebSocket</button>
  </div>

  <!-- –ò–≥—Ä–∞ -->
  <div id="game-screen" class="screen">
    <h1>üó∫Ô∏è –ò–≥—Ä–∞</h1>
    <div id="game-info">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
    <div id="board"></div>
    <div class="players-status">
      <div>–ò–≥—Ä–æ–∫ 1: <span id="player1-status">üü¢ –û–Ω–ª–∞–π–Ω</span></div>
      <div>–ò–≥—Ä–æ–∫ 2: <span id="player2-status">üü¢ –û–Ω–ª–∞–π–Ω</span></div>
    </div>
    <div class="connection-status connected" id="game-connection-status">
      –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ: –°—Ç–∞–±–∏–ª—å–Ω–æ–µ
    </div>
    <button id="btn-game-back" class="btn red">–í—ã–π—Ç–∏ –∏–∑ –∏–≥—Ä—ã</button>
  </div>

  <script>
    // =============================
    // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
    // =============================
    let peer = null;
    let websocket = null;
    let currentPeerId = null;
    let conn = null;
    let roomId = null;
    let isHost = false;
    let isLocalMode = false;
    let playerRole = null; // 'player1' –∏–ª–∏ 'player2'
    let connectionType = 'webrtc'; // 'webrtc' –∏–ª–∏ 'websocket'
    let connectionAttempts = 0;
    let maxAttempts = 5;
    let reconnectTimeout = null;
    let connectionEstablished = false;
    let lastActivity = Date.now();
    let heartbeatInterval = null;

    // –ò–≥—Ä–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    const size = 10;
    let currentPlayer = 1;
    let phase = 'placeTraps';
    let traps = new Map();
    let playerPos = { 1: [9, 0], 2: [9, 0] };
    let trapsPlaced = { 1: 0, 2: 0 };
    const maxTraps = 3;

    // DOM —ç–ª–µ–º–µ–Ω—Ç—ã
    const screens = {
      menu: document.getElementById('menu-screen'),
      host: document.getElementById('host-screen'),
      guest: document.getElementById('guest-screen'),
      game: document.getElementById('game-screen')
    };
    const boardEl = document.getElementById('board');
    const gameInfo = document.getElementById('game-info');
    const hostCodeEl = document.getElementById('host-code');
    const qrCodeEl = document.getElementById('qr-code');
    const guestCodeEl = document.getElementById('guest-code');
    const hostStatusEl = document.getElementById('host-status');
    const guestStatusEl = document.getElementById('guest-status');
    const hostLogEl = document.getElementById('host-log');
    const guestLogEl = document.getElementById('guest-log');
    const gameConnectionStatusEl = document.getElementById('game-connection-status');
    const forceWebsocketBtn = document.getElementById('btn-force-websocket');

    // =============================
    // === –§–£–ù–ö–¶–ò–ò –õ–û–ì–ò–†–û–í–ê–ù–ò–Ø ===
    // =============================
    function logMessage(element, message, isError = false) {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = document.createElement('div');
      logEntry.style.color = isError ? '#ff6b6b' : '#4ecdc4';
      logEntry.innerHTML = `<span style="color:#aaa;">[${timestamp}]</span> ${message}`;
      element.appendChild(logEntry);
      element.scrollTop = element.scrollHeight;
    }

    function logHost(message, isError = false) {
      logMessage(hostLogEl, message, isError);
    }

    function logGuest(message, isError = false) {
      logMessage(guestLogEl, message, isError);
    }

    // =============================
    // === –§–£–ù–ö–¶–ò–ò –ü–û–ö–ê–ó–ê –≠–ö–†–ê–ù–û–í ===
    // =============================
    function showScreen(name) {
      Object.values(screens).forEach(s => s.classList.remove('active'));
      screens[name].classList.add('active');
    }

    // =============================
    // === –ù–ê–î–ï–ñ–ù–û–ï –°–û–ï–î–ò–ù–ï–ù–ò–ï ===
    // =============================
    function setupStableConnection() {
      // –ó–∞–ø—É—Å–∫–∞–µ–º heartbeat –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
      startHeartbeat();
      
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
      document.addEventListener('visibilitychange', handleVisibilityChange);
      
      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–∫—Ä—ã—Ç–∏—è –≤–∫–ª–∞–¥–∫–∏
      window.addEventListener('beforeunload', cleanupConnections);
    }

    function startHeartbeat() {
      clearInterval(heartbeatInterval);
      heartbeatInterval = setInterval(() => {
        if (!connectionEstablished) return;
        
        const now = Date.now();
        if (now - lastActivity > 30000) { // 30 —Å–µ–∫—É–Ω–¥ –±–µ–∑ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
          logMessage(gameConnectionStatusEl.parentElement, '–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å, –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...', true);
          checkConnectionHealth();
        }
      }, 10000); // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
    }

    function checkConnectionHealth() {
      if (connectionType === 'webrtc' && conn && conn.open) {
        try {
          conn.send({ type: 'heartbeat', timestamp: Date.now() });
          return true;
        } catch (e) {
          logMessage(gameConnectionStatusEl.parentElement, 'WebRTC heartbeat failed, –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ WebSocket...', true);
          switchToWebsocketFallback();
          return false;
        }
      } else if (connectionType === 'websocket' && websocket && websocket.readyState === WebSocket.OPEN) {
        try {
          websocket.send(JSON.stringify({ type: 'heartbeat', timestamp: Date.now() }));
          return true;
        } catch (e) {
          logMessage(gameConnectionStatusEl.parentElement, 'WebSocket heartbeat failed, –ø–æ–ø—ã—Ç–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è...', true);
          attemptReconnect();
          return false;
        }
      }
      return false;
    }

    function switchToWebsocketFallback() {
      connectionType = 'websocket';
      
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        logMessage(gameConnectionStatusEl.parentElement, '–£–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º WebSocket, –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è');
        return;
      }
      
      // –ó–∞–∫—Ä—ã–≤–∞–µ–º WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
      if (conn) {
        try { conn.close(); } catch (e) {}
        conn = null;
      }
      
      // –°–æ–∑–¥–∞–µ–º WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
      const wsUrl = `wss://socketsbay.com/wss/v2/2/${roomId}/`;
      websocket = new WebSocket(wsUrl);
      
      websocket.onopen = () => {
        logMessage(gameConnectionStatusEl.parentElement, 'WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ (fallback)');
        connectionEstablished = true;
        gameConnectionStatusEl.textContent = '–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ: WebSocket (—Ä–µ–∑–µ—Ä–≤–Ω—ã–π)';
        gameConnectionStatusEl.className = 'connection-status connected';
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
        websocket.send(JSON.stringify({
          type: 'join',
          roomId,
          playerId: playerRole,
          isHost
        }));
      };
      
      websocket.onmessage = (event) => {
        lastActivity = Date.now();
        try {
          const data = JSON.parse(event.data);
          handleNetworkMessage(data);
        } catch (e) {
          logMessage(gameConnectionStatusEl.parentElement, `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ WebSocket —Å–æ–æ–±—â–µ–Ω–∏—è: ${e.message}`, true);
        }
      };
      
      websocket.onclose = () => {
        logMessage(gameConnectionStatusEl.parentElement, 'WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ, –ø–æ–ø—ã—Ç–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è...', true);
        gameConnectionStatusEl.textContent = '–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ: –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ...';
        gameConnectionStatusEl.className = 'connection-status reconnecting';
        attemptReconnect();
      };
      
      websocket.onerror = (error) => {
        logMessage(gameConnectionStatusEl.parentElement, `WebSocket –æ—à–∏–±–∫–∞: ${error.message}`, true);
      };
    }

    function attemptReconnect() {
      if (connectionAttempts >= maxAttempts) {
        logMessage(gameConnectionStatusEl.parentElement, '–î–æ—Å—Ç–∏–≥–Ω—É—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫, —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ', true);
        cleanupConnections();
        showScreen('menu');
        alert('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Å–æ–ø–µ—Ä–Ω–∏–∫–æ–º –ø–æ—Ç–µ—Ä—è–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É.');
        return;
      }
      
      connectionAttempts++;
      logMessage(gameConnectionStatusEl.parentElement, `–ü–æ–ø—ã—Ç–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è (${connectionAttempts}/${maxAttempts})...`);
      
      gameConnectionStatusEl.textContent = '–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ: –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ...';
      gameConnectionStatusEl.className = 'connection-status reconnecting';
      
      // –ß–µ—Ä–µ–¥—É–µ–º —Ç–∏–ø—ã –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–∫–∞—Ö
      if (connectionType === 'webrtc') {
        switchToWebsocketFallback();
      } else {
        // –ü—ã—Ç–∞–µ–º—Å—è –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ WebRTC
        setupWebRTConnection();
      }
    }

    function setupWebRTConnection() {
      if (peer) {
        try { peer.destroy(); } catch (e) {}
      }
      
      // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è PeerJS
      currentPeerId = 'player-' + Math.random().toString(36).substring(2, 12);
      
      peer = new Peer(currentPeerId, {
        host: '0.peerjs.com',
        port: 443,
        path: '/',
        secure: true,
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' }
          ]
        },
        debug: 1
      });

      peer.on('open', (id) => {
        logMessage(gameConnectionStatusEl.parentElement, `PeerJS ID: ${id}`);
        connectionAttempts = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –æ—Ç–∫—Ä—ã—Ç–∏–∏
      });

      peer.on('error', (err) => {
        logMessage(gameConnectionStatusEl.parentElement, `PeerJS –æ—à–∏–±–∫–∞: ${err.message}`, true);
        
        if (err.type === 'unavailable-id' || err.type === 'network') {
          if (connectionAttempts < maxAttempts) {
            setTimeout(() => {
              logMessage(gameConnectionStatusEl.parentElement, '–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ WebRTC –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è...');
              setupWebRTConnection();
            }, 2000 * connectionAttempts);
          } else {
            logMessage(gameConnectionStatusEl.parentElement, 'WebRTC –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ WebSocket', true);
            switchToWebsocketFallback();
          }
        }
      });
    }

    function handleVisibilityChange() {
      if (document.visibilityState === 'visible') {
        // –ü—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –Ω–∞ –≤–∫–ª–∞–¥–∫—É –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        setTimeout(() => {
          if (connectionEstablished) {
            checkConnectionHealth();
          }
        }, 1000);
      }
    }

    function cleanupConnections() {
      clearInterval(heartbeatInterval);
      
      if (conn) {
        try { conn.close(); } catch (e) {}
        conn = null;
      }
      
      if (peer) {
        try { peer.destroy(); } catch (e) {}
        peer = null;
      }
      
      if (websocket) {
        try { websocket.close(); } catch (e) {}
        websocket = null;
      }
      
      clearTimeout(reconnectTimeout);
      connectionEstablished = false;
      connectionAttempts = 0;
    }

    // =============================
    // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò–ì–†–´ ===
    // =============================
    function initBoard() {
      boardEl.innerHTML = '';
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = r;
          cell.dataset.col = c;
          if (r === 9 && c === 0) cell.classList.add('start');
          if (r === 0 && c === 9) cell.classList.add('treasure');
          boardEl.appendChild(cell);
        }
      }
    }

    function updateGameInfo() {
      gameInfo.className = '';
      if (phase === 'ended') {
        gameInfo.textContent = '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!';
        gameInfo.style.background = 'rgba(255,255,255,0.9)';
        gameInfo.style.color = '#27ae60';
        return;
      }

      if (isLocalMode) {
        gameInfo.textContent = phase === 'placeTraps' 
          ? `–í—ã–±–æ—Ä –ª–æ–≤—É—à–µ–∫: –ò–≥—Ä–æ–∫ ${currentPlayer}`
          : `–•–æ–¥ –∏–≥—Ä–æ–∫–∞ ${currentPlayer}`;
        gameInfo.classList.add(currentPlayer === 1 ? 'player-1-turn' : 'player-2-turn');
      } else {
        const isMyTurn = (playerRole === 'player1' && currentPlayer === 1) ||
                         (playerRole === 'player2' && currentPlayer === 2);
        gameInfo.textContent = isMyTurn ? `–í–∞—à —Ö–æ–¥!` : `–•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...`;
        gameInfo.classList.add(currentPlayer === 1 ? 'player-1-turn' : 'player-2-turn');
      }
    }

    function render() {
      document.querySelectorAll('.cell').forEach(cell => {
        cell.classList.remove('player', 'trap-revealed');
        cell.textContent = '';
      });

      // –ò–∫–æ–Ω–∫–∏ —Å—Ç–∞—Ä—Ç–∞ –∏ —Å–æ–∫—Ä–æ–≤–∏—â–∞
      document.querySelector('.start').textContent = 'üè†';
      document.querySelector('.treasure').textContent = 'üèÜ';

      // –ü–æ–∫–∞–∑ –ª–æ–≤—É—à–µ–∫: —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ –∏ —Ç–æ–ª—å–∫–æ –≤ —Ñ–∞–∑–µ —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏
      if (phase === 'placeTraps') {
        const myPlayerId = isLocalMode ? currentPlayer : (playerRole === 'player1' ? 1 : 2);
        traps.forEach((owner, key) => {
          if (owner === myPlayerId) {
            const [r, c] = key.split(',').map(Number);
            const el = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
            if (el) el.textContent = '‚ö†Ô∏è';
          }
        });
      }

      // –ü–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–æ–≤
      for (const [id, [r, c]] of Object.entries(playerPos)) {
        const el = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
        if (el) {
          el.classList.add('player');
          el.textContent = `P${id}`;
        }
      }

      updateGameInfo();
    }

    // =============================
    // === –ó–í–£–ö–ò (Web Audio API) ===
    // =============================
    let audioCtx;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
      console.log('Web Audio API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
    }

    function playTone(freq, dur = 0.1, type = 'sine', vol = 0.15) {
      if (!audioCtx) return;
      
      try {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type; 
        o.frequency.value = freq;
        g.gain.value = vol;
        g.connect(audioCtx.destination);
        o.connect(g);
        o.start(); 
        o.stop(audioCtx.currentTime + dur);
      } catch (e) {
        console.log('–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∑–≤—É–∫–∞');
      }
    }

    // =============================
    // === –õ–û–ö–ê–õ–¨–ù–´–ô –†–ï–ñ–ò–ú ===
    // =============================
    function startLocalGame() {
      isLocalMode = true;
      resetGameState();
      showScreen('game');
      render();
    }

    function placeTrapLocal(row, col) {
      if (phase !== 'placeTraps') return;
      if ((row === 9 && col === 0) || (row === 0 && col === 9)) return;
      const key = `${row},${col}`;
      if (traps.has(key)) return;

      traps.set(key, currentPlayer);
      trapsPlaced[currentPlayer]++;

      playTone(520, 0.15);

      if (trapsPlaced[currentPlayer] >= maxTraps) {
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        if (trapsPlaced[currentPlayer] >= maxTraps) {
          currentPlayer = 1;
          phase = 'playGame';
        }
      }
      render();
    }

    function movePlayerLocal(dr, dc) {
      if (phase !== 'playGame') return;
      const [r, c] = playerPos[currentPlayer];
      let nr = r + dr;
      let nc = c + dc;

      if (nr < 0 || nr >= size || nc < 0 || nc >= size) return;
      if (Math.abs(dr) + Math.abs(dc) !== 1) return;

      playerPos[currentPlayer] = [nr, nc];
      playTone(300, 0.1, 'square');

      const key = `${nr},${nc}`;
      if (traps.has(key)) {
        const owner = traps.get(key);
        if (owner !== currentPlayer) {
          const cell = document.querySelector(`.cell[data-row="${nr}"][data-col="${nc}"]`);
          cell.classList.add('trap-revealed');
          cell.textContent = `T${owner}`;
          playTone(150, 0.4, 'sawtooth', 0.25);

          setTimeout(() => {
            cell.classList.remove('trap-revealed');
            cell.textContent = '';
            playerPos[currentPlayer] = [9, 0];
            alert(`–ò–≥—Ä–æ–∫ ${currentPlayer} –ø–æ–ø–∞–ª –≤ –ª–æ–≤—É—à–∫—É –ò–≥—Ä–æ–∫–∞ ${owner}! –í–æ–∑–≤—Ä–∞—Ç –Ω–∞ —Å—Ç–∞—Ä—Ç.`);
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            render();
          }, 600);
          return;
        }
      }

      if (nr === 0 && nc === 9) {
        document.querySelector('.treasure').classList.add('win');
        if (audioCtx) {
          const t = audioCtx.currentTime;
          [523, 659, 784].forEach((f, i) => {
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.frequency.value = f;
            g.gain.setValueAtTime(0.12, t + i * 0.2);
            g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.2 + 0.3);
            o.connect(g).connect(audioCtx.destination);
            o.start(t + i * 0.2);
            o.stop(t + i * 0.2 + 0.3);
          });
        }
        setTimeout(() => {
          alert(`üéâ –ò–≥—Ä–æ–∫ ${currentPlayer} –ø–æ–±–µ–¥–∏–ª!`);
        }, 300);
        phase = 'ended';
        render();
        return;
      }

      currentPlayer = currentPlayer === 1 ? 2 : 1;
      render();
    }

    // =============================
    // === –°–¢–ê–ë–ò–õ–¨–ù–´–ô –ú–£–õ–¨–¢–ò–ü–õ–ï–ï–† ===
    // =============================
    function generateRoomId() {
      return Math.random().toString(36).substring(2, 10).toUpperCase();
    }

    function createOnlineGame() {
      cleanupConnections();
      setupStableConnection();
      
      roomId = generateRoomId();
      isHost = true;
      playerRole = 'player1';
      connectionType = 'webrtc';
      connectionAttempts = 0;
      connectionEstablished = false;
      
      hostCodeEl.textContent = roomId;
      guestCodeEl.value = roomId;
      
      // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º QR –∫–æ–¥
      generateQRCode(roomId);
      
      // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
      setupWebRTConnection();
      
      // –ñ–¥–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≥–æ—Å—Ç—è
      peer.on('connection', (connection) => {
        conn = connection;
        setupConnectionEvents();
        
        logHost('–ì–æ—Å—Ç—å –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è —á–µ—Ä–µ–∑ WebRTC');
        connectionEstablished = true;
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º, —á—Ç–æ –≥–æ—Å—Ç—å –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è
        document.querySelector('#host-screen .players-list').innerHTML = `
          <div>–ò–≥—Ä–æ–∫ 1 (–í—ã): ‚úÖ –û–Ω–ª–∞–π–Ω</div>
          <div>–ò–≥—Ä–æ–∫ 2: ‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω!</div>
        `;
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        setTimeout(() => {
          sendGameState();
          startOnlineGame();
        }, 1000);
      });
      
      showScreen('host');
      logHost(`–°–æ–∑–¥–∞–Ω–∞ –∫–æ–º–Ω–∞—Ç–∞: ${roomId}`);
      logHost('–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≥–æ—Å—Ç—è...');
    }

    function joinOnlineGame(code) {
      cleanupConnections();
      setupStableConnection();
      
      if (!code || code.length < 4) {
        alert('–í–≤–µ–¥–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã');
        return;
      }
      
      roomId = code.toUpperCase();
      isHost = false;
      playerRole = 'player2';
      connectionType = 'webrtc';
      connectionAttempts = 0;
      connectionEstablished = false;
      
      guestCodeEl.value = roomId;
      guestStatusEl.textContent = '–°—Ç–∞—Ç—É—Å: –ü–æ–∏—Å–∫ —Ö–æ—Å—Ç–∞...';
      guestStatusEl.className = 'connection-status connecting';
      
      showScreen('guest');
      logGuest(`–ü–æ–ø—ã—Ç–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –∫–æ–º–Ω–∞—Ç–µ: ${roomId}`);
      
      // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
      setupWebRTConnection();
      
      // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Ö–æ—Å—Ç—É
      setTimeout(() => {
        if (!peer || !peer.id) {
          logGuest('PeerJS –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω, –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ WebSocket', true);
          switchToWebsocketFallbackForGuest();
          return;
        }
        
        const hostId = 'host-' + roomId;
        
        try {
          conn = peer.connect(hostId, {
            reliable: true,
            serialization: 'json'
          });
          
          setupConnectionEvents();
          
          conn.on('open', () => {
            logGuest('WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ');
            guestStatusEl.textContent = '–°—Ç–∞—Ç—É—Å: –ü–æ–¥–∫–ª—é—á–µ–Ω–æ! –û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä—ã...';
            guestStatusEl.className = 'connection-status connected';
            connectionEstablished = true;
          });
          
          conn.on('error', (err) => {
            logGuest(`WebRTC –æ—à–∏–±–∫–∞: ${err.message}`, true);
            if (connectionAttempts < maxAttempts) {
              setTimeout(() => {
                logGuest('–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ WebRTC –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è...');
                joinOnlineGame(code);
              }, 3000);
            } else {
              logGuest('WebRTC –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ WebSocket', true);
              switchToWebsocketFallbackForGuest();
            }
          });
        } catch (e) {
          logGuest(`–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: ${e.message}`, true);
          switchToWebsocketFallbackForGuest();
        }
      }, 2000);
    }

    function switchToWebsocketFallbackForGuest() {
      forceWebsocketBtn.classList.remove('hidden');
      
      forceWebsocketBtn.onclick = () => {
        forceWebsocketBtn.classList.add('hidden');
        
        const wsUrl = `wss://socketsbay.com/wss/v2/2/${roomId}/`;
        websocket = new WebSocket(wsUrl);
        
        websocket.onopen = () => {
          logGuest('WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ (–ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ)');
          guestStatusEl.textContent = '–°—Ç–∞—Ç—É—Å: –ü–æ–¥–∫–ª—é—á–µ–Ω–æ —á–µ—Ä–µ–∑ WebSocket';
          guestStatusEl.className = 'connection-status connected';
          connectionEstablished = true;
          connectionType = 'websocket';
          
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
          websocket.send(JSON.stringify({
            type: 'join',
            roomId,
            playerId: playerRole,
            isHost: false
          }));
        };
        
        websocket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            handleNetworkMessage(data);
          } catch (e) {
            logGuest(`–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ WebSocket —Å–æ–æ–±—â–µ–Ω–∏—è: ${e.message}`, true);
          }
        };
        
        websocket.onclose = () => {
          logGuest('WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ', true);
          guestStatusEl.textContent = '–°—Ç–∞—Ç—É—Å: –û—Ç–∫–ª—é—á–µ–Ω–æ';
          guestStatusEl.className = 'connection-status disconnected';
        };
        
        websocket.onerror = (error) => {
          logGuest(`WebSocket –æ—à–∏–±–∫–∞: ${error.message}`, true);
        };
      };
    }

    function setupConnectionEvents() {
      if (!conn) return;
      
      conn.on('open', () => {
        logMessage(gameConnectionStatusEl.parentElement, '–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ');
        connectionEstablished = true;
        gameConnectionStatusEl.textContent = '–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ: –°—Ç–∞–±–∏–ª—å–Ω–æ–µ';
        gameConnectionStatusEl.className = 'connection-status connected';
      });

      conn.on('data', (data) => {
        lastActivity = Date.now();
        handleNetworkMessage(data);
      });

      conn.on('close', () => {
        logMessage(gameConnectionStatusEl.parentElement, '–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ', true);
        if (screens.game.classList.contains('active')) {
          gameConnectionStatusEl.textContent = '–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ: –†–∞–∑–æ—Ä–≤–∞–Ω–æ';
          gameConnectionStatusEl.className = 'connection-status disconnected';
          attemptReconnect();
        }
      });

      conn.on('error', (err) => {
        logMessage(gameConnectionStatusEl.parentElement, `–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: ${err.message}`, true);
        if (screens.game.classList.contains('active')) {
          attemptReconnect();
        }
      });
    }

    function handleNetworkMessage(data) {
      if (!data.type) return;
      
      switch (data.type) {
        case 'game_state':
          syncGameState(data.state);
          break;
          
        case 'game_action':
          processRemoteAction(data.action, data.payload);
          break;
          
        case 'game_start':
          startOnlineGame();
          break;
          
        case 'heartbeat':
          lastActivity = Date.now();
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
          if (connectionType === 'webrtc' && conn && conn.open) {
            conn.send({ type: 'heartbeat_ack', timestamp: data.timestamp });
          }
          break;
          
        case 'heartbeat_ack':
          lastActivity = Date.now();
          break;
      }
    }

    function sendGameState() {
      if (connectionType === 'webrtc' && conn && conn.open) {
        try {
          conn.send({
            type: 'game_state',
            state: {
              currentPlayer,
              phase,
              traps: Object.fromEntries(traps),
              playerPos,
              trapsPlaced
            }
          });
          return true;
        } catch (e) {
          logMessage(gameConnectionStatusEl.parentElement, `–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —á–µ—Ä–µ–∑ WebRTC: ${e.message}`, true);
          return false;
        }
      } else if (connectionType === 'websocket' && websocket && websocket.readyState === WebSocket.OPEN) {
        try {
          websocket.send(JSON.stringify({
            type: 'game_state',
            state: {
              currentPlayer,
              phase,
              traps: Object.fromEntries(traps),
              playerPos,
              trapsPlaced
            }
          }));
          return true;
        } catch (e) {
          logMessage(gameConnectionStatusEl.parentElement, `–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —á–µ—Ä–µ–∑ WebSocket: ${e.message}`, true);
          return false;
        }
      }
      return false;
    }

    function sendGameAction(action, payload) {
      lastActivity = Date.now();
      
      if (connectionType === 'webrtc' && conn && conn.open) {
        try {
          conn.send({
            type: 'game_action',
            action,
            payload
          });
          return true;
        } catch (e) {
          logMessage(gameConnectionStatusEl.parentElement, `–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–µ–π—Å—Ç–≤–∏—è —á–µ—Ä–µ–∑ WebRTC: ${e.message}`, true);
          // –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —á–µ—Ä–µ–∑ WebSocket –∫–∞–∫ fallback
          return sendGameActionFallback(action, payload);
        }
      } else {
        return sendGameActionFallback(action, payload);
      }
    }

    function sendGameActionFallback(action, payload) {
      if (connectionType === 'websocket' && websocket && websocket.readyState === WebSocket.OPEN) {
        try {
          websocket.send(JSON.stringify({
            type: 'game_action',
            action,
            payload
          }));
          return true;
        } catch (e) {
          logMessage(gameConnectionStatusEl.parentElement, `–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —á–µ—Ä–µ–∑ WebSocket: ${e.message}`, true);
          return false;
        }
      }
      return false;
    }

    function syncGameState(state) {
      currentPlayer = state.currentPlayer;
      phase = state.phase;
      traps = new Map(Object.entries(state.traps || {}));
      playerPos = state.playerPos;
      trapsPlaced = state.trapsPlaced;
      render();
    }

    function processRemoteAction(action, payload) {
      switch (action) {
        case 'place_trap':
          if (phase !== 'placeTraps') return;
          
          const { row, col, playerId } = payload;
          const key = `${row},${col}`;
          
          if ((row === 9 && col === 0) || (row === 0 && col === 9)) return;
          if (traps.has(key)) return;
          
          traps.set(key, playerId);
          trapsPlaced[playerId]++;
          
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏
          if (trapsPlaced[1] >= maxTraps && trapsPlaced[2] >= maxTraps) {
            phase = 'playGame';
            currentPlayer = 1;
          } else {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
          }
          
          render();
          break;
          
        case 'move':
          if (phase !== 'playGame') return;
          
          const { dr, dc, movingPlayerId } = payload;
          const [r, c] = playerPos[movingPlayerId];
          const nr = r + dr;
          const nc = c + dc;
          
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü
          if (nr < 0 || nr >= size || nc < 0 || nc >= size) return;
          if (Math.abs(dr) + Math.abs(dc) !== 1) return;
          
          playerPos[movingPlayerId] = [nr, nc];
          
          const moveKey = `${nr},${nc}`;
          
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–æ–≤—É—à–µ–∫
          if (traps.has(moveKey)) {
            const trapOwner = traps.get(moveKey);
            if (trapOwner !== movingPlayerId) {
              // –ü–æ–ø–∞–ª –≤ —á—É–∂—É—é –ª–æ–≤—É—à–∫—É
              setTimeout(() => {
                playerPos[movingPlayerId] = [9, 0];
                if (movingPlayerId === currentPlayer) {
                  currentPlayer = currentPlayer === 1 ? 2 : 1;
                }
                render();
              }, 600);
            }
          }
          
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã
          if (nr === 0 && nc === 9) {
            phase = 'ended';
          } else if (!traps.has(moveKey) || traps.get(moveKey) === movingPlayerId) {
            // –ü–µ—Ä–µ–¥–∞—á–∞ —Ö–æ–¥–∞
            currentPlayer = currentPlayer === 1 ? 2 : 1;
          }
          
          render();
          break;
      }
    }

    function startOnlineGame() {
      resetGameState();
      showScreen('game');
      render();
      
      if (isHost) {
        // –•–æ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∫–æ–º–∞–Ω–¥—É –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã
        setTimeout(() => {
          sendGameState();
        }, 500);
      }
    }

    function resetGameState() {
      currentPlayer = 1;
      phase = 'placeTraps';
      traps = new Map();
      playerPos = { 1: [9, 0], 2: [9, 0] };
      trapsPlaced = { 1: 0, 2: 0 };
      initBoard();
    }

    // =============================
    // === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ===
    // =============================
    function generateQRCode(data) {
      try {
        const qr = qrcode(0, 'L');
        qr.addData(data);
        qr.make();
        qrCodeEl.innerHTML = qr.createImgTag(4, 10);
      } catch (e) {
        qrCodeEl.innerHTML = `<div style="color:white;padding:10px;">QR –∫–æ–¥: ${data}</div>`;
        logHost('QR –∫–æ–¥ –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω', true);
      }
    }

    // =============================
    // === –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ===
    // =============================
    boardEl.addEventListener('click', (e) => {
      if (!e.target.classList.contains('cell') || phase === 'ended') return;
      
      const r = parseInt(e.target.dataset.row);
      const c = parseInt(e.target.dataset.col);

      if (isLocalMode) {
        if (phase === 'placeTraps') {
          placeTrapLocal(r, c);
        } else if (phase === 'playGame') {
          const [pr, pc] = playerPos[currentPlayer];
          movePlayerLocal(r - pr, c - pc);
        }
      } else {
        // –û–Ω–ª–∞–π–Ω —Ä–µ–∂–∏–º
        if (phase === 'placeTraps') {
          const isMyTurn = (playerRole === 'player1' && currentPlayer === 1) ||
                           (playerRole === 'player2' && currentPlayer === 2);
          if (!isMyTurn) return;

          if ((r === 9 && c === 0) || (r === 0 && c === 9)) return;
          const key = `${r},${c}`;
          
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ
          sendGameAction('place_trap', { 
            row: r, 
            col: c, 
            playerId: playerRole === 'player1' ? 1 : 2 
          });
        } else if (phase === 'playGame') {
          const isMyTurn = (playerRole === 'player1' && currentPlayer === 1) ||
                           (playerRole === 'player2' && currentPlayer === 2);
          if (!isMyTurn) return;

          const myPlayerId = playerRole === 'player1' ? 1 : 2;
          const [pr, pc] = playerPos[myPlayerId];
          const dr = r - pr;
          const dc = c - pc;
          
          if (Math.abs(dr) + Math.abs(dc) !== 1) return;
          
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ
          sendGameAction('move', { 
            dr, 
            dc, 
            movingPlayerId: myPlayerId 
          });
        }
      }
    });

    // =============================
    // === –ö–ù–û–ü–ö–ò –ú–ï–ù–Æ ===
    // =============================
    document.getElementById('btn-local').onclick = startLocalGame;
    
    document.getElementById('btn-create').onclick = createOnlineGame;
    
    document.getElementById('btn-join').onclick = () => {
      const code = document.getElementById('room-code').value.trim();
      if (code) {
        joinOnlineGame(code);
      } else {
        alert('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã');
      }
    };
    
    document.getElementById('btn-cancel-host').onclick = () => {
      cleanupConnections();
      showScreen('menu');
    };
    
    document.getElementById('btn-cancel-guest').onclick = () => {
      cleanupConnections();
      showScreen('menu');
    };
    
    document.getElementById('btn-game-back').onclick = () => {
      cleanupConnections();
      showScreen('menu');
    };

    // =============================
    // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
    // =============================
    window.onload = () => {
      initBoard();
      
      // –ü–æ–ø—ã—Ç–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∞—É–¥–∏–æ –ø–æ –ø–µ—Ä–≤–æ–º—É –∫–ª–∏–∫—É
      document.body.addEventListener('click', () => {
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
      }, { once: true });
      
      // –ó–∞–≥—Ä—É–∂–∞–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –¥–ª—è QR –∫–æ–¥–∞
      loadQRScript();
      loadPeerJSScript();
    };

    function loadQRScript() {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js';
      script.async = true;
      script.onload = () => {
        console.log('QR –∫–æ–¥ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞');
      };
      document.head.appendChild(script);
    }

    function loadPeerJSScript() {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js';
      script.async = true;
      script.onload = () => {
        console.log('PeerJS –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞');
      };
      document.head.appendChild(script);
    };
  </script>
</body>
</html>
